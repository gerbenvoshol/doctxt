// Copyright 2010 Christoph GÃ¤rtner
// Copyright 2020 Gerben Vsohol
// Distributed under the following license
// Boost Software License - Version 1.0 - August 17th, 2003

// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:

// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// tXML is a minimal XML parser, supporting only the most basic feature set
// this excludes (among other things) document types, comments, processing
// instructions, CDATA sections and entity decoding

#ifndef TXML_H
#define TXML_H

#include <stddef.h>
#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef __cplusplus
	#define TXML_EXTERN   extern "C"
#else
	#define TXML_EXTERN   extern
#endif

enum txml_types
{
	TXML_EOF = 0, // only used internally
	TXML_ELEMENT = 1,
	TXML_ATTRIBUTE = 2,
	TXML_TEXT = 3
};

struct txml_node
/*	an XML node
	element nodes have a <NULL> value
	text nodes have the name "#text"
*/
{
	enum txml_types type;
	struct txml_node *parent;
	const char *name;
	const char *value;
};

TXML_EXTERN char *txml_parse(
	char *data, size_t max_nodes, struct txml_node *nodes);
/*	parses up to <max_nodes> of XML and returns a pointer to the unprocessed
	data; parsing is destructive, ie <data> will be modified

	returns <NULL> if <data> could be parsed completely
*/

TXML_EXTERN char *txml_read_file(const char *filename);
/*	read entire file into null terminated character array

	returns <NULL> if <filename> could NOT be read otherwise <data>
*/

TXML_EXTERN char *txml_parse_file(char *filename, struct txml_node **nodes);
/*	Tries to parse all of the XML and returns a pointer to the processed
	data and filles the nodes list

	returns <NULL> if <data> could NOT be parsed completely otherwise ,data. which needs
	to be freed!
*/

TXML_EXTERN struct txml_node *txml_next(
	struct txml_node *node, struct txml_node *ancestor, _Bool child,
	enum txml_types type);
/*	gets the next node in the document structure which has a given <type> and
	is a descendant of <ancestor>;  returns <NULL> if there is no such node

	if <ancestor> is <NULL>, <node->parent> will be used

	if <child> is true, only direct children of <ancestor> will be considered

	<type> may hold a combination of types by using logical or
*/


TXML_EXTERN struct txml_node *txml_prev(
	struct txml_node *node, struct txml_node *ancestor, _Bool child,
	enum txml_types type);
/*	gets the previous node in the document structure according to the same
	semantics as <txml_next()>
*/

TXML_EXTERN struct txml_node *txml_find(
	struct txml_node *root, struct txml_node *current, enum txml_types type,
	const char *name, const char *value, _Bool deep);
/*	finds the first child of <root> whose name or value compares equal
	to <name> or <value> respectively; returns <NULL> if no such node could
	be found

	if <current> is not <NULL>, only nodes which succeed <current> will be
	searched

	<type> may hold a combination of types by using logical or

	if either <name> or <value> is <NULL>, only the other will be considered

	if <deep> is true, all descendants of <root> (and not only direct
	children) will be considered
*/

TXML_EXTERN struct txml_node *txml_get(
	struct txml_node *root, struct txml_node *current, size_t path_len,
	const char **path);
/*	finds a node by resolving <path>, starting at <root>; reutrns <NULL> if no
	such node could be found

	<path> must point to the first element of an array of <path_len>
	strings; each element of <path> is a node's name, where text nodes are
	represented by "#text" and attribute node names must be prefixed by "@"

	if <current> is not <NULL>, only nodes which succeed <current> will be
	considered
*/

/*	an (incomplete) DOM Level 1 wrapper for tinyXML
*/

typedef struct txml_node *dom_node_t;

TXML_EXTERN size_t dom_getElementsByTagName(
	dom_node_t root, const char *name, size_t max_nodes, dom_node_t *nodes);

TXML_EXTERN dom_node_t dom_getElementById(
	dom_node_t root, const char *id);

TXML_EXTERN dom_node_t dom_nextSibling(
	dom_node_t node);

TXML_EXTERN dom_node_t dom_prevSibling(
	dom_node_t node);

TXML_EXTERN dom_node_t dom_firstChild(
	dom_node_t node);

TXML_EXTERN _Bool dom_hasChildNodes(
	dom_node_t node);

TXML_EXTERN size_t dom_childNodes(
	dom_node_t node, size_t max_nodes, dom_node_t *nodes);

TXML_EXTERN const char *dom_getAttribute(
	dom_node_t node, const char *name);

TXML_EXTERN size_t txml_get_text_content(
	struct txml_node *node, char *buffer, size_t buffer_size);
/* Extracts all text content from a node and its descendants into buffer.
 * Returns the number of characters written (excluding null terminator).
 * If buffer is NULL, only calculates and returns the required size.
 * Useful for extracting concatenated text from complex structures.
 */

#ifdef TXML_DEFINE

enum txml_parse_states
{
	TXML_PARSE_TEXT,
	TXML_PARSE_ELEMENT,
	TXML_PARSE_CLOSING_ELEMENT,
	TXML_PARSE_ELEMENT_NAME,
	TXML_PARSE_ATTRIBUTES,
	TXML_PARSE_ATTRIBUTE_NAME,
	TXML_PARSE_ATTRIBUTE_VALUE,
	TXML_PARSE_XML_DECLARATION,
	TXML_PARSE_ERROR,
	TXML_PARSE_FINISHED
};

char *txml_parse_names[] = {
	"TXML_PARSE_TEXT",
	"TXML_PARSE_ELEMENT",
	"TXML_PARSE_CLOSING_ELEMENT",
	"TXML_PARSE_ELEMENT_NAME",
	"TXML_PARSE_ATTRIBUTES",
	"TXML_PARSE_ATTRIBUTE_NAME",
	"TXML_PARSE_ATTRIBUTE_VALUE",
	"TXML_PARSE_XML_DECLARATION",
	"TXML_PARSE_ERROR",
	"TXML_PARSE_FINISHED"
};

struct txml_node *txml_next(
	struct txml_node *node, struct txml_node *ancestor, _Bool child,
	enum txml_types type)
{
	if(!ancestor) ancestor = node->parent;

	for(++node; node->type && node->parent >= ancestor; ++node)
	{
		if((node->type & type) && (!child || node->parent == ancestor))
			return node;
	}

	return NULL;
}

struct txml_node *txml_prev(
	struct txml_node *node, struct txml_node *ancestor, _Bool child,
	enum txml_types type)
{
	if(!ancestor) ancestor = node->parent;

	for(--node; node > ancestor; --node)
	{
		if((node->type & type) && (!child || node->parent == ancestor))
			return node;
	}

	return NULL;
}

struct txml_node *txml_find(
	struct txml_node *root, struct txml_node *current, enum txml_types type,
	const char *name, const char *value, _Bool deep)
{
	if(!current) current = root;

	for(;;)
	{
		current = txml_next(current, root, !deep, type);
		if(!current || (
			(!name || strcmp(current->name, name) == 0) &&
			(!value || strcmp(current->value, value) == 0)))
			return current;
	}
}

struct txml_node *txml_get(
	struct txml_node *root, struct txml_node *current, size_t path_len,
	const char **path)
{
	enum txml_types type = (path[path_len - 1][0] == '@') ? TXML_ATTRIBUTE :
		(strcmp(path[path_len - 1], "#text") == 0) ? TXML_TEXT : TXML_ELEMENT;

	for(;;)
	{
		current = txml_find(root, current, type,
			path[path_len - 1] + (type == TXML_ATTRIBUTE ? 1 : 0), NULL, 1);

		if(!current || path_len == 1)
			return current;

		struct txml_node *ancestor = current->parent;
		size_t pos = path_len - 2;

		for(; ancestor > root && strcmp(path[pos], ancestor->name) == 0;
			ancestor = ancestor->parent, --pos)
		{
			if(pos == 0)
				return current;
		}
	}
}

#define put_node(...) \
	do { if(!count--) return data; put_node_(&nodes, __VA_ARGS__); } while(0)

static inline void put_node_(
	struct txml_node **nodes, enum txml_types type, struct txml_node *parent,
	const char *name, const char *value)
{
	(*nodes)->type = type;
	(*nodes)->parent = parent;
	(*nodes)->name = name;
	(*nodes)->value = value;
	++*nodes;
}

char *txml_read_file(const char *filename)
{
	char *buffer = 0;
	size_t length;
	
	// Open file
	FILE *file = fopen(filename, "rb");
	if (!file) {
		fprintf(stderr, "Unable to open %s\n", filename);
		return NULL;
	}

	// Determine the end of the file
	fseek(file, 0, SEEK_END);
	// Get the length
	length = ftell(file);
	// Rewind file
	fseek(file, 0, SEEK_SET);

	// Allocate space
	buffer = malloc(length + 1);
	// Read file content
	fread(buffer, 1, length, file);

	// Close the file
	fclose(file);

	// Terminate with \0 !
	buffer[length] = '\0';

	return buffer;
}

char *txml_parse_file(char *filename, struct txml_node **nodes)
{
	char *data;
	char *doc = txml_read_file(filename);
	if (!doc) {
		return NULL;
	}

	size_t allocated = 31250; // 1 Mb
	struct txml_node *lnodes = malloc(allocated * sizeof(struct txml_node));
	while ((data = txml_parse(doc, allocated, lnodes))) {
		//fprintf(stderr, "Reallocating...");
		free(doc);
		free(lnodes);
		allocated *= 2;
		lnodes = malloc(allocated * sizeof(struct txml_node));
		if (!lnodes) {
			fprintf(stderr, "Unable to allocate sufficient memory\n");
			return NULL;
		}
		doc = txml_read_file(filename);
	}

	//fprintf(stderr, "Allocated: %li nodes (%li Mb)\n", allocated, (allocated * 32) / 1000000);
	*nodes = lnodes;
	return doc;
}

char *txml_parse(
	char *data, size_t count, struct txml_node *nodes)
{
	enum txml_parse_states txml_parse_state = TXML_PARSE_TEXT;
	int error_number;
	char *marks[3] = { data };
	char *start;
	char c;
	struct txml_node *parent = nodes;
	put_node(TXML_EOF, NULL, NULL, NULL);

	for (;;) {
		switch (txml_parse_state) {
			case TXML_PARSE_TEXT:
				// printf("parse_text: %.20s...\n", data);
				while(*data && *data != '<') ++data;

				c = *data;

				if(data > marks[0])
				{
					put_node(TXML_TEXT, parent, "#text", marks[0]);
					*data = 0;

					if(!parent->value)
						parent->value = marks[0];
				}

				if(c == '<') {
					++data;
					txml_parse_state = TXML_PARSE_ELEMENT;
					break;
				}

				put_node(TXML_EOF, NULL, NULL, NULL);
				
				error_number = TXML_PARSE_TEXT;
				txml_parse_state = TXML_PARSE_FINISHED;
				break;
			case TXML_PARSE_ELEMENT:
				//printf("parse_elem: %.20s...\n", data);
				if(*data == '/') {
					data++;
					txml_parse_state = TXML_PARSE_CLOSING_ELEMENT;
					break;
				}

				while(isspace(*data)) ++data;

				c = *data;

				if(isalnum(*data))
				{
					marks[0] = data;
					txml_parse_state = TXML_PARSE_ELEMENT_NAME;
					break;
				}

				//printf("HERE %c\n", c);
				if (c == '?') { 
					txml_parse_state = TXML_PARSE_XML_DECLARATION;
					//printf("HERE\n");
					break;
				}

				error_number = TXML_PARSE_ELEMENT;
				txml_parse_state = TXML_PARSE_ERROR;
				break;
			case TXML_PARSE_CLOSING_ELEMENT:
				// printf("parse_closing_elem: %.20s...\n", data);
				while(isspace(*data)) ++data;

				start = data;
				while(*data && (isalnum(*data) || *data == '-' || *data == '_' || *data == '.' || *data == ':')) ++data;
				while(isspace(*data)) ++data;


				if(*data != '>') {
					error_number = TXML_PARSE_CLOSING_ELEMENT;
					txml_parse_state = TXML_PARSE_ERROR;
					break;
				}

				*data = 0;

				if(!parent->name || strcmp(parent->name, start)) {
					data = start;
					error_number = TXML_PARSE_CLOSING_ELEMENT;
					txml_parse_state = TXML_PARSE_ERROR;
					break;
				}

				parent = parent->parent;

				marks[0] = data + 1;

				data++;
				txml_parse_state = TXML_PARSE_TEXT;
				break;
			case TXML_PARSE_ELEMENT_NAME:
				/* Element names are case-sensitive.
		    	 * Element names must start with a letter or underscore.
		    	 * Element names cannot start with the letters xml (or XML, or Xml, etc)
		    	 * Element names can contain letters, digits, hyphens, underscores, and periods.
		    	 * Element names cannot contain spaces.
				 */
				// printf("parse_elem_name: %.20s...\n", data);
				while(*data && (isalnum(*data) || *data == '-' || *data == '_' || *data == '.' || *data == ':')) ++data;

				put_node(TXML_ELEMENT, parent, marks[0], NULL);
				parent = nodes - 1;

				c = *data;
				*data = 0;

				if(c == '>')
				{
					marks[0] = data + 1;
					++data;
					txml_parse_state = TXML_PARSE_TEXT;
					break;
				}
				else if(c == '/')
				{
					if(*++data == '>')
					{
						parent = parent->parent;
						marks[0] = data + 1;
						txml_parse_state = TXML_PARSE_TEXT;
						break;
					}

					error_number = TXML_PARSE_ELEMENT_NAME;
					txml_parse_state = TXML_PARSE_ERROR;
					break;
				}
				else if(isspace(c))
				{
					++data;
					txml_parse_state = TXML_PARSE_ATTRIBUTES;
					break;				
				}

				error_number = TXML_PARSE_ELEMENT_NAME;
				txml_parse_state = TXML_PARSE_ERROR;
				break;
			case TXML_PARSE_ATTRIBUTES:
				// printf("parse_attr: %.20s...\n", data);
				while(isspace(*data)) ++data;

				if (isalnum(*data) || *data == '-' || *data == '_' || *data == '.')
				{
					marks[0] = data;
					txml_parse_state = TXML_PARSE_ATTRIBUTE_NAME;
					break;
				}
				else if(*data == '>')
				{
					marks[0] = data + 1;
					txml_parse_state = TXML_PARSE_TEXT;
					break;
				}
				else if(*data == '/')
				{
					if(*++data == '>')
					{
						parent = parent->parent;
						marks[0] = data + 1;
						txml_parse_state = TXML_PARSE_TEXT;
						break;
					}
					error_number = TXML_PARSE_ATTRIBUTES;
					txml_parse_state = TXML_PARSE_ERROR;
					break;
				}

				error_number = TXML_PARSE_ATTRIBUTES;
				txml_parse_state = TXML_PARSE_ERROR;
				break;
			case TXML_PARSE_ATTRIBUTE_NAME:
				// printf("parse_attr_name: %.20s...\n", data);
				while(isalnum(*data) || *data == '-' || *data == '_' || *data == '.' || *data == ':') ++data;

				marks[1] = data;

				while(isspace(*data)) ++data;

				if(*data == '=') {
					++data;
					txml_parse_state = TXML_PARSE_ATTRIBUTE_VALUE;
					break;
				}

				error_number = TXML_PARSE_ATTRIBUTE_NAME;
				txml_parse_state = TXML_PARSE_ERROR;
				break;
			case TXML_PARSE_ATTRIBUTE_VALUE:
				// printf("parse_attr_value: %.20s...\n", data);
				while(isspace(*data)) ++data;

				marks[2] = data + 1;

				c = *data;

				if(c != '"' && c != '\'') {
					error_number = TXML_PARSE_ATTRIBUTE_VALUE;
					txml_parse_state = TXML_PARSE_ERROR;
					break;
				}

				++data;

				for(; *data; ++data)
				{
					if(*data == '\\') {
						if(*++data == 0) {
							error_number = TXML_PARSE_ATTRIBUTE_VALUE;
							txml_parse_state = TXML_PARSE_ERROR;
							break;
						}
					// Find the matching "
					} else if(*data == c) {
						put_node(TXML_ATTRIBUTE, parent, marks[0], marks[2]);

						*marks[1] = 0;
						*data = 0;

						++data;
						txml_parse_state = TXML_PARSE_ATTRIBUTES;
						break;
					}
				}

				if (txml_parse_state != TXML_PARSE_ATTRIBUTES) {
					error_number = TXML_PARSE_ATTRIBUTE_VALUE;
					txml_parse_state = TXML_PARSE_ERROR;
				}

				break;
			case TXML_PARSE_XML_DECLARATION:
				// Skip past the XML declaration line
				while(*data && *data != '>') ++data;

				// Reset mark so that we will skip the XML declaration line
				marks[0] = data + 2;

				txml_parse_state = TXML_PARSE_TEXT;
				break;
				
				error_number = TXML_PARSE_XML_DECLARATION;
				txml_parse_state = TXML_PARSE_ERROR;
				break;
			case TXML_PARSE_ERROR:
				fprintf(stderr, "Error during state %s at: %.20s...\n", txml_parse_names[error_number], data);
				return data;
				break;
			case TXML_PARSE_FINISHED:
				return NULL;
				break;
			default:
				fprintf(stderr, "Unknown parse state!\n");
				txml_parse_state = TXML_PARSE_ERROR;
				break;
		}
	}
}

dom_node_t dom_getElementById(
	dom_node_t root, const char *id)
{
	dom_node_t node = txml_find(root, NULL, TXML_ATTRIBUTE, "id", id, 1);
	return node ? node->parent : NULL;
}

dom_node_t dom_nextSibling(
	dom_node_t node)
{
	return txml_next(node, NULL, 1, TXML_ELEMENT | TXML_TEXT);
}

dom_node_t dom_prevSibling(
	dom_node_t node)
{
	return txml_prev(node, NULL, 1, TXML_ELEMENT | TXML_TEXT);
}

dom_node_t dom_firstChild(
	dom_node_t node)
{
	return txml_next(node, node, 1, TXML_ELEMENT | TXML_TEXT);
}

const char *dom_getAttribute(
	dom_node_t node, const char *name)
{
	dom_node_t attribute = txml_find(node, NULL, TXML_ATTRIBUTE, name, NULL, 0);
	return attribute ? attribute->value : NULL;
}

size_t dom_getElementsByTagName(
	dom_node_t root, const char *name, size_t max_nodes, dom_node_t *nodes)
{
	size_t count = 0;

	dom_node_t current = NULL;
	for(; count < max_nodes; ++count)
	{
		current = txml_find(root, current, TXML_ELEMENT, name, NULL, 1);
		if(current) nodes[count] = current;
		else break;
	}

	return count;
}

_Bool dom_hasChildNodes(
	dom_node_t node)
{
	return txml_find(node, NULL, TXML_ELEMENT | TXML_TEXT, NULL, NULL, 0);
}

size_t dom_childNodes(
	dom_node_t node, size_t max_nodes, dom_node_t *nodes)
{
	size_t count = 0;

	dom_node_t current = NULL;
	for(; count < max_nodes; ++count)
	{
		current = txml_next(current, node, 1, TXML_ELEMENT | TXML_TEXT);
		if(current) nodes[count] = current;
		else break;
	}

	return count;
}

size_t txml_get_text_content(
	struct txml_node *node, char *buffer, size_t buffer_size)
{
	if (!node) return 0;
	
	size_t total = 0;
	struct txml_node *current = node + 1;  // Start with first child
	
	/* Traverse descendants looking for text nodes.
	 * We stop when we encounter a node that's not a descendant.
	 * To check if a node is a descendant, we walk up its parent chain
	 * looking for our target node.
	 */
	while (current->type != TXML_EOF) {
		/* Check if current node is a descendant by walking up parent chain */
		int is_descendant = 0;
		struct txml_node *ancestor = current->parent;
		
		/* Walk up the parent chain - descendants will eventually reach 'node' */
		while (ancestor) {
			if (ancestor == node) {
				is_descendant = 1;
				break;
			}
			/* Stop if we've reached a root node (parent points to itself or NULL) */
			if (ancestor->type == TXML_EOF || ancestor->parent == ancestor) {
				break;
			}
			ancestor = ancestor->parent;
		}
		
		if (!is_descendant) {
			break;  // We've left the subtree
		}
		
		/* Extract text from text nodes */
		if (current->type == TXML_TEXT && current->value) {
			size_t len = strlen(current->value);
			if (buffer && total + len < buffer_size) {
				memcpy(buffer + total, current->value, len);
			}
			total += len;
		}
		current++;
	}
	
	if (buffer && total < buffer_size) {
		buffer[total] = '\0';
	}
	
	return total;
}

#ifdef TXML_EXAMPLE

#include <assert.h>

#define count(ARRAY) (sizeof (ARRAY) / sizeof *(ARRAY))

int main(void)
{
	struct txml_node nodes[32];
	char data[] = "<root><foo bar='spam'/><foo bar='eggs'/></root>";

	char *tail = txml_parse(data, count(nodes), nodes);
	assert(!tail); // check for parsing success

	puts("--- tx ---"); // use tx API
	const char *path[] = { "root", "foo", "@bar" };
	struct txml_node *current_bar = NULL;
	while((current_bar = txml_get(nodes, current_bar, count(path), path)))
		puts(current_bar->value);

	puts("--- dom ---"); // use DOM wrapper
	dom_node_t foo_nodes[8];
	size_t count = dom_getElementsByTagName(
		nodes, "foo", count(foo_nodes), foo_nodes);

	size_t i = 0;
	for(; i < count; ++i)
		puts(dom_getAttribute(foo_nodes[i], "bar"));
}

#endif // TXML_EXAMPLE
#endif // TXML_DEFINE
#endif // TXML_H